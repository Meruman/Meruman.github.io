<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,user-scalable=no"><link rel=stylesheet type=text/css href=/css/main.css><noscript><link rel=stylesheet href=/css/noscript.css></noscript><title>Martin MeRu | Procedural Animation</title></head><body class=is-preload><div id=wrapper><nav id=nav><a href=#home class="icon solid fa-home"><span>Home</span></a>
<a href=#portfolio class="icon solid fa-folder"><span>Portfolio</span></a>
<a href=#blog class="icon solid fa-blog" style=padding-left:1.5%><span>Blog</span></a>
<a href=#games class="icon solid fa-gamepad"><span>Games</span></a>
<a href=#aboutme class="icon solid fa-user-tie"><span>About</span></a></nav><div id=main><h1>Procedural Animation</h1><p><h3><a class=title href=/posts/12.-lost_in_the_forest/>Lost in the forest in Unreal Engine</a></h3><i data-feather=calendar></i>
<time datetime=2023-02-22>Feb 22, 2023</time>
<i data-feather=tag></i>
<a class="btn btn-sm btn-outline-dark tag-btn" href=https://meruman.github.io/tags/unreal-engine>Unreal Engine</a>
<a class="btn btn-sm btn-outline-dark tag-btn" href=https://meruman.github.io/tags/ai>AI</a>
<a class="btn btn-sm btn-outline-dark tag-btn" href=https://meruman.github.io/tags/procedural-animation>Procedural Animation</a>
<a class=summary href=/posts/12.-lost_in_the_forest/><p>Description: For this project, I developed a Unity Pong game where a human player can play against an artificial pong paddle that is trained with an artificial neural network. The game involves bouncing a ball back and forth between two paddles, and the objective is to score points by getting the ball past the opponent&rsquo;s paddle. The artificial paddle is able to learn and improve its performance over time through the use of a neural network, making it a challenging opponent for players to face.</p></a></p><p><h3><a class=title href=/posts/12.-lost_in_the_forest_blog/>Creating Lost in the forest in Unreal Engine</a></h3><i data-feather=calendar></i>
<time datetime=2023-02-22>Feb 22, 2023</time>
<i data-feather=tag></i>
<a class="btn btn-sm btn-outline-dark tag-btn" href=https://meruman.github.io/tags/unreal-engine>Unreal Engine</a>
<a class="btn btn-sm btn-outline-dark tag-btn" href=https://meruman.github.io/tags/ai>AI</a>
<a class="btn btn-sm btn-outline-dark tag-btn" href=https://meruman.github.io/tags/procedural-animation>Procedural animation</a>
<a class=summary href=/posts/12.-lost_in_the_forest_blog/><p>Description: Key Learnings: Tools and Technologies Used: Outcome: Future Improvements: Description: In this project, I created a population manager in Unity using genetic algorithms to navigate a maze. The project involved setting up a population of bots, breeding them, and evaluating their fitness in order to evolve a population that can successfully navigate a maze.
Key Learnings: Creating a population manager in Unity using genetic algorithms Implementing fitness functions in genetic algorithms Managing data structures using lists in C# Applying good coding practices, such as commenting and using informative variable names Testing and experimenting with different parameters to fine-tune the genetic algorithm and improve the quality of the solutions it generates.</p></a></p></div><div class=row><div class=col-12><br><section class=contact><div style=margin-bottom:4%;color:darkgrey>Reach out to me on any of these channels:</div><ul class=icons><li><a href=https://meruman.itch.io/ class="icon brands fa-itch-io"><span class=label>itch.io</span></a></li><li><a href=https://www.youtube.com/channel/UCQA363EbfyEFmT3F7QYkCyg class="icon brands fa-youtube"><span class=label>Youtube</span></a></li><li><a href=https://www.twitch.tv/meruman class="icon brands fa-twitch"><span class=label>Twitch</span></a></li><li><a href=https://www.instagram.com/meru.games/ class="icon brands fa-instagram"><span class=label>Instagram</span></a></li><li><a href=https://www.linkedin.com/in/martinmeru/ class="icon brands fa-linkedin-in"><span class=label>Linkedin</span></a></li><li><a href=https://github.com/Meruman class="icon brands fa-github"><span class=label>Github</span></a></li></ul></section></div></div></div><script src=/js/jquery.min.js></script>
<script src=/js/browser.min.js></script>
<script src=/js/breakpoints.min.js></script>
<script src=/js/jquery.scrollex.min.js></script>
<script src=/js/main.js></script>
<script src=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js></script>
<script src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.1/highlight.min.js></script>
<script>hljs.highlightAll()</script><script>const main_section=document.querySelector("#main")</script><script>$(document).ready(function(){$(".blog-entry[data-blog-id='10']").click(function(e){if(e.preventDefault(),document.body.style.overflow="hidden",$(".left-column").empty(),null){document.getElementById("blog-colums").className="two-columns";let e="";null.forEach(function(t){e+=`<img src="${t}" />`}),$(".left-column").html(e)}else document.getElementById("blog-colums").className="one-column";$(".blog-entry-content").html(`\u003ch3 id=\u0022description\u0022\u003e\u003cstrong\u003eDescription:\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eI\u0026rsquo;m thrilled to present this game development project, a top-down shooter game made in Unity. The unique aspect of this project is that all the image assets were generated by Stable difussion and the plot was created by ChatGPT. The purpose of this project is to showcase how efficient and productive AI tools can be when used in game development.\u003c/p\u003e
\u003ch3 id=\u0022key-skills-demonstrated\u0022\u003e\u003cstrong\u003eKey Skills Demonstrated:\u003c/strong\u003e\u003c/h3\u003e
\u003cul\u003e
\u003cli\u003eGame development using Unity engine\u003c/li\u003e
\u003cli\u003eImplementation of artificial intelligence techniques, specifically neural networks\u003c/li\u003e
\u003cli\u003eObject-oriented programming principles\u003c/li\u003e
\u003cli\u003eProblem-solving and debugging skills\u003c/li\u003e
\u003c/ul\u003e
\u003ch3 id=\u0022tools-and-technologies-used\u0022\u003e\u003cstrong\u003eTools and Technologies Used:\u003c/strong\u003e\u003c/h3\u003e
\u003cul\u003e
\u003cli\u003eUnity game engine\u003c/li\u003e
\u003cli\u003eC# programming language\u003c/li\u003e
\u003cli\u003eVisual Studio code editor\u003c/li\u003e
\u003c/ul\u003e
\u003ch3 id=\u0022details\u0022\u003e\u003cstrong\u003eDetails:\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eThe game consists of three main classes: Brain, HumanPlayer, and MoveBall. The Brain class contains the neural network that controls the movement of the artificial paddle. The HumanPlayer class allows a human player to control the other paddle using keyboard input. The MoveBall class handles the movement of the ball and collision detection with the paddles and walls.\u003c/p\u003e
\u003cp\u003eThe neural network used in the game is a simple feedforward network with one hidden layer. It takes in the current position of the ball and the paddle, as well as their velocities, as input, and outputs a prediction for the vertical movement of the paddle. The weights of the neural network are updated using backpropagation and stochastic gradient descent during each training episode.\u003c/p\u003e
\u003cp\u003eDuring gameplay, the artificial paddle starts out with random weights and learns through trial and error as it plays against the human player. The performance of the paddle is evaluated based on the number of points it scores against the human player, and the weights are updated accordingly. As the paddle trains, it becomes progressively more skilled at the game, providing a challenging opponent for the human player.\u003c/p\u003e
\u003ch3 id=\u0022outcome\u0022\u003e\u003cstrong\u003eOutcome:\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eThe resulting game is a fun and engaging way for players to test their skills against an AI opponent. The use of a neural network to train the artificial paddle allows for a challenging opponent that adapts and improves over time, providing an exciting and dynamic gameplay experience. The project also demonstrates proficiency in game development and AI techniques.\u003c/p\u003e
\u003ch3 id=\u0022future-improvements\u0022\u003e\u003cstrong\u003eFuture Improvements:\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eThere are several ways that this project could be expanded and improved in the future. Some potential areas for enhancement include:\u003c/p\u003e
\u003cul\u003e
\u003cli\u003eAdding additional layers to the neural network to improve performance\u003c/li\u003e
\u003cli\u003eImplementing more advanced AI techniques, such as reinforcement learning or genetic algorithms\u003c/li\u003e
\u003cli\u003eAdding additional features to the game, such as power-ups or obstacles, to make gameplay more varied and interesting.\u003c/li\u003e
\u003c/ul\u003e
`),$(".modal-title").html("Adventure land in Unreal engine"),$(".PortfolioImage").attr("src","/images/giphy.gif"),$(".modal-container").fadeIn(),$(".modal-container").scrollTop(0)}),$(".close").click(function(){document.body.style.overflow="auto",$(".modal-container").fadeOut()}),$(".modal-container").click(function(e){e.target==this&&(document.body.style.overflow="auto",$(".modal-container").fadeOut())})})</script><script>$(document).ready(function(){$(".blog-entry[data-blog-id='9']").click(function(e){if(e.preventDefault(),document.body.style.overflow="hidden",$(".left-column").empty(),null){document.getElementById("blog-colums").className="two-columns";let e="";null.forEach(function(t){e+=`<img src="${t}" />`}),$(".left-column").html(e)}else document.getElementById("blog-colums").className="one-column";$(".blog-entry-content").html(`\u003ch3 id=\u0022description\u0022\u003e\u003cstrong\u003eDescription:\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eI\u0026rsquo;m thrilled to present this game development project, a top-down shooter game made in Unity. The unique aspect of this project is that all the image assets were generated by Stable difussion and the plot was created by ChatGPT. The purpose of this project is to showcase how efficient and productive AI tools can be when used in game development.\u003c/p\u003e
\u003ch3 id=\u0022concept-and-design\u0022\u003e\u003cstrong\u003eConcept and Design\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eThe game\u0026rsquo;s concept is centered around an alien invasion on a distant planet. Players take on the role of a space explorer who must collect valuable resources while fending off hostile aliens. The player character is a humanoid in a space suit, while the aliens come in various sizes and shapes, each with their own unique attack patterns. The player has a selection of weapons at their disposal, including a plasma rifle, flamethrower, and EMP gun.\u003c/p\u003e
\u003ch3 id=\u0022tools-and-technologies-used\u0022\u003e\u003cstrong\u003eTools and Technologies Used\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eTo create this project, I used Unity as the game engine and GIMP to modify the image assets generated by DallE. ChatGPT was used to provide guidance and feedback throughout the development process.\u003c/p\u003e
\u003ch3 id=\u0022goals-and-objectives\u0022\u003e\u003cstrong\u003eGoals and Objectives\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eThe primary goal of this project is to create a functional and engaging top-down shooter game that showcases the efficient use of AI tools in game development. I aimed to create a game that provides a challenging and enjoyable experience for players as they navigate through different terrains and battle various types of aliens to ultimately defeat the Big Boss Alien.\u003c/p\u003e
\u003ch3 id=\u0022development-process\u0022\u003e\u003cstrong\u003eDevelopment Process\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eI began by creating a game design document (GDD) to outline the game\u0026rsquo;s concept, objectives, and mechanics. The image assets were generated using DallE and modified with GIMP to fit the game\u0026rsquo;s design. Unity was used to create the game\u0026rsquo;s mechanics, UI, and overall functionality. ChatGPT was used to provide guidance and feedback throughout the development process.\u003c/p\u003e
\u003ch3 id=\u0022art-and-sound\u0022\u003e\u003cstrong\u003eArt and Sound\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eThe game features a visually stunning art style that includes all image assets generated by DallE and modified with GIMP. Sound effects and music were added to enhance the overall gameplay experience.\u003c/p\u003e
\u003ch3 id=\u0022gameplay-and-demo\u0022\u003e\u003cstrong\u003eGameplay and Demo\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eThe gameplay involves the player navigating through different terrains and battling various types of aliens to reach the ultimate goal of defeating the Big Boss Alien. The game includes weapon power-ups and health drops, adding an extra strategic element to the gameplay. A demo version of the game is available to showcase the game\u0026rsquo;s mechanics and overall design.\u003c/p\u003e
\u003ch3 id=\u0022skills-learned\u0022\u003e\u003cstrong\u003eSkills learned\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eThroughout the development of this project, I gained valuable skills in game design, Unity development, image asset modification using GIMP, and efficient use of AI tools for game development.\u003c/p\u003e
\u003ch3 id=\u0022future-plans\u0022\u003e\u003cstrong\u003eFuture Plans\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eFuture plans for the game may include adding additional levels, characters, and weapons power-ups to enhance the player\u0026rsquo;s experience. Additionally, adding multiplayer capabilities could make the game more engaging for players. I also look forward to exploring the use of other AI tools for game development in my future projects.\u003c/p\u003e
`),$(".modal-title").html("Alien invasion in unity with Stable diffusion"),$(".PortfolioImage").attr("src","/images/giphy.gif"),$(".modal-container").fadeIn(),$(".modal-container").scrollTop(0)}),$(".close").click(function(){document.body.style.overflow="auto",$(".modal-container").fadeOut()}),$(".modal-container").click(function(e){e.target==this&&(document.body.style.overflow="auto",$(".modal-container").fadeOut())})})</script><script>$(document).ready(function(){$(".blog-entry[data-blog-id='8']").click(function(e){if(e.preventDefault(),document.body.style.overflow="hidden",$(".left-column").empty(),null){document.getElementById("blog-colums").className="two-columns";let e="";null.forEach(function(t){e+=`<img src="${t}" />`}),$(".left-column").html(e)}else document.getElementById("blog-colums").className="one-column";$(".blog-entry-content").html(`\u003ch3 id=\u0022project-overview\u0022\u003e\u003cstrong\u003eProject Overview\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eThis project is a simple game called \u0026ldquo;Alien Ranger\u0026rdquo; created using Python and Pygame library. The game features a player catching aliens and aims to achieve high scores. The game\u0026rsquo;s image assets were generated using DallE, an AI language model that creates images from textual descriptions. Using generated images for game development provides unique, high-quality graphics that can be customized for the specific game\u0026rsquo;s requirements.\u003c/p\u003e
\u003ch3 id=\u0022concept-and-design\u0022\u003e\u003cstrong\u003eConcept and Design\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eAlien Ranger is a single-player game where the player is tasked with catching aliens of a specific color. The game has multiple rounds, with each round having more aliens than before. To get points, the player must catch the target alien while avoiding other aliens, the game ends when the player loses all their lives.\u003c/p\u003e
\u003ch3 id=\u0022tools-and-technologies-used\u0022\u003e\u003cstrong\u003eTools and Technologies Used\u003c/strong\u003e\u003c/h3\u003e
\u003cul\u003e
\u003cli\u003ePython\u003c/li\u003e
\u003cli\u003eVisual studio code\u003c/li\u003e
\u003cli\u003eStable diffusion\u003c/li\u003e
\u003c/ul\u003e
\u003ch3 id=\u0022goals-and-objectives\u0022\u003e\u003cstrong\u003eGoals and Objectives\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eThe goal of the game is to achieve a high score by catching as many target aliens as possible. The player has three lives, and losing a life by catching the wrong alien reduces the player\u0026rsquo;s score. The game gets progressively more challenging as the rounds progress, with the target alien moving faster and the number of aliens increasing.\u003c/p\u003e
\u003ch3 id=\u0022development-process\u0022\u003e\u003cstrong\u003eDevelopment Process\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eThe game was developed using Python and Pygame library. The code sets up the game window, initializes game objects, and sets up the game loop to handle user input and update the game state. The GameManager class was created to manage the gameplay and handle collisions between the player and the aliens. The game was iteratively developed, with each feature tested and refined before moving on to the next.\u003c/p\u003e
\u003ch3 id=\u0022art-and-sound\u0022\u003e\u003cstrong\u003eArt and Sound\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eAll image assets in the game were generated using DallE, an AI language model that creates images from textual descriptions. The generated images provide a unique and customizable look to the game, and the use of AI-generated images has become increasingly popular in game development. The game features sound effects and music, adding to the overall gaming experience.\u003c/p\u003e
\u003ch3 id=\u0022gameplay-and-demo\u0022\u003e\u003cstrong\u003eGameplay and Demo\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eThe gameplay involves catching aliens while avoiding other aliens. The target alien is highlighted with a rectangle, and catching the wrong alien results in the player losing a life. The game gets progressively more challenging, with faster-moving target aliens and an increasing number of aliens on screen. The demo version of the game showcases the game\u0026rsquo;s core mechanics, such as catching the correct alien, avoiding the wrong one, and the game\u0026rsquo;s increasing difficulty.\u003c/p\u003e
\u003ch3 id=\u0022future-plans\u0022\u003e\u003cstrong\u003eFuture Plans\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eFuture plans for the game include adding new features such as different game modes, and adding more AI-generated Aliens. The game can also be ported to other platforms such as mobile devices or consoles, expanding the game\u0026rsquo;s reach to a wider audience.\u003c/p\u003e
`),$(".modal-title").html("Alien ranger in Pygame with Stable diffusion"),$(".PortfolioImage").attr("src","/images/giphy.gif"),$(".modal-container").fadeIn(),$(".modal-container").scrollTop(0)}),$(".close").click(function(){document.body.style.overflow="auto",$(".modal-container").fadeOut()}),$(".modal-container").click(function(e){e.target==this&&(document.body.style.overflow="auto",$(".modal-container").fadeOut())})})</script><script>$(document).ready(function(){$(".blog-entry[data-blog-id='6']").click(function(e){if(e.preventDefault(),document.body.style.overflow="hidden",$(".left-column").empty(),null){document.getElementById("blog-colums").className="two-columns";let e="";null.forEach(function(t){e+=`<img src="${t}" />`}),$(".left-column").html(e)}else document.getElementById("blog-colums").className="one-column";$(".blog-entry-content").html(`\u003ch3 id=\u0022description\u0022\u003e\u003cstrong\u003eDescription:\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eCatch the Lion is a fun and interactive game created using Python and the Pygame library. The objective of the game is to catch the lion by clicking on it with your mouse. The game is designed to test your reflexes and hand-eye coordination, while providing an entertaining experience.ce.\u003c/p\u003e
\u003ch3 id=\u0022key-skills-demonstrated\u0022\u003e\u003cstrong\u003eKey Skills Demonstrated:\u003c/strong\u003e\u003c/h3\u003e
\u003cul\u003e
\u003cli\u003eGame development using Python\u003c/li\u003e
\u003cli\u003ePygame library usage\u003c/li\u003e
\u003cli\u003eUser input handling\u003c/li\u003e
\u003cli\u003eAudio and music integration\u003c/li\u003e
\u003c/ul\u003e
\u003ch3 id=\u0022tools-and-technologies-used\u0022\u003e\u003cstrong\u003eTools and Technologies Used:\u003c/strong\u003e\u003c/h3\u003e
\u003cul\u003e
\u003cli\u003ePython 3.10\u003c/li\u003e
\u003cli\u003ePygame library\u003c/li\u003e
\u003cli\u003eGit version control\u003c/li\u003e
\u003cli\u003eVisual Studio code editor\u003c/li\u003e
\u003c/ul\u003e
\u003ch3 id=\u0022details\u0022\u003e\u003cstrong\u003eDetails:\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eThe game is built using Python 3.10 and Pygame library, which provides an easy-to-use interface for game development. The game script imports various modules such as pygame, random, asyncio, os, and sys. The script starts by initializing Pygame library using pygame.init() function.\u003c/p\u003e
\u003cp\u003eThe game window is set up with the required dimensions, and game values such as the window size, frames per second, player lives, lion velocity, and lion acceleration are defined. Colors and fonts are also defined, and sounds, images, and music are loaded into the game.\u003c/p\u003e
\u003cp\u003eThe game loop is defined as an asynchronous function called main(). This function takes input from the user, such as mouse clicks, and updates the game state accordingly. If the user clicks on the lion, their score is incremented, and the lion\u0026rsquo;s speed and direction are randomly changed. If the user misses the lion, their number of remaining lives is decremented.\u003c/p\u003e
\u003cp\u003eThe game updates the positions of the lion and other assets, such as the HUD and background, and displays them on the screen using the blit() function. If the player loses all their lives, the game over screen is displayed. The game will continue running until the user closes the game window.\u003c/p\u003e
\u003ch3 id=\u0022outcome\u0022\u003e\u003cstrong\u003eOutcome:\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eThe outcome of the project is an interactive and entertaining game that provides a fun experience for users. The game showcases my skills in Python and Pygame library, user input handling, graphics design, and audio and music integration.\u003c/p\u003e
\u003ch3 id=\u0022future-improvements\u0022\u003e\u003cstrong\u003eFuture Improvements:\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eThere are several areas where the game can be improved, such as adding more levels, power-ups, and difficulty levels. The game\u0026rsquo;s graphics and audio can also be improved to enhance the user experience. Additionally, the game\u0026rsquo;s performance can be optimized to run smoother on different devices.\u003c/p\u003e
`),$(".modal-title").html("Catch the lion in Pygame"),$(".PortfolioImage").attr("src","/images/giphy.gif"),$(".modal-container").fadeIn(),$(".modal-container").scrollTop(0)}),$(".close").click(function(){document.body.style.overflow="auto",$(".modal-container").fadeOut()}),$(".modal-container").click(function(e){e.target==this&&(document.body.style.overflow="auto",$(".modal-container").fadeOut())})})</script><script>$(document).ready(function(){$(".blog-entry[data-blog-id='11']").click(function(e){if(e.preventDefault(),document.body.style.overflow="hidden",$(".left-column").empty(),["/images/giphy.gif"]){document.getElementById("blog-colums").className="two-columns";let e="";["/images/giphy.gif"].forEach(function(t){e+=`<img src="${t}" />`}),$(".left-column").html(e)}else document.getElementById("blog-colums").className="one-column";$(".blog-entry-content").html(`\u003ch3 id=\u0022description\u0022\u003e\u003cstrong\u003eDescription:\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eFor this project, I developed a Unity Pong game where a human player can play against an artificial pong paddle that is trained with an artificial neural network. The game involves bouncing a ball back and forth between two paddles, and the objective is to score points by getting the ball past the opponent\u0026rsquo;s paddle. The artificial paddle is able to learn and improve its performance over time through the use of a neural network, making it a challenging opponent for players to face.\u003c/p\u003e
\u003ch3 id=\u0022key-skills-demonstrated\u0022\u003e\u003cstrong\u003eKey Skills Demonstrated:\u003c/strong\u003e\u003c/h3\u003e
\u003cul\u003e
\u003cli\u003eGame development using Unity engine\u003c/li\u003e
\u003cli\u003eImplementation of artificial intelligence techniques, specifically neural networks\u003c/li\u003e
\u003cli\u003eObject-oriented programming principles\u003c/li\u003e
\u003cli\u003eProblem-solving and debugging skills\u003c/li\u003e
\u003c/ul\u003e
\u003ch3 id=\u0022tools-and-technologies-used\u0022\u003e\u003cstrong\u003eTools and Technologies Used:\u003c/strong\u003e\u003c/h3\u003e
\u003cul\u003e
\u003cli\u003eUnity game engine\u003c/li\u003e
\u003cli\u003eC# programming language\u003c/li\u003e
\u003cli\u003eVisual Studio code editor\u003c/li\u003e
\u003c/ul\u003e
\u003ch3 id=\u0022details\u0022\u003e\u003cstrong\u003eDetails:\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eThe game consists of three main classes: Brain, HumanPlayer, and MoveBall. The Brain class contains the neural network that controls the movement of the artificial paddle. The HumanPlayer class allows a human player to control the other paddle using keyboard input. The MoveBall class handles the movement of the ball and collision detection with the paddles and walls.\u003c/p\u003e
\u003cp\u003eThe neural network used in the game is a simple feedforward network with one hidden layer. It takes in the current position of the ball and the paddle, as well as their velocities, as input, and outputs a prediction for the vertical movement of the paddle. The weights of the neural network are updated using backpropagation and stochastic gradient descent during each training episode.\u003c/p\u003e
\u003cp\u003eDuring gameplay, the artificial paddle starts out with random weights and learns through trial and error as it plays against the human player. The performance of the paddle is evaluated based on the number of points it scores against the human player, and the weights are updated accordingly. As the paddle trains, it becomes progressively more skilled at the game, providing a challenging opponent for the human player.\u003c/p\u003e
\u003ch3 id=\u0022outcome\u0022\u003e\u003cstrong\u003eOutcome:\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eThe resulting game is a fun and engaging way for players to test their skills against an AI opponent. The use of a neural network to train the artificial paddle allows for a challenging opponent that adapts and improves over time, providing an exciting and dynamic gameplay experience. The project also demonstrates proficiency in game development and AI techniques.\u003c/p\u003e
\u003ch3 id=\u0022future-improvements\u0022\u003e\u003cstrong\u003eFuture Improvements:\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eThere are several ways that this project could be expanded and improved in the future. Some potential areas for enhancement include:\u003c/p\u003e
\u003cul\u003e
\u003cli\u003eAdding additional layers to the neural network to improve performance\u003c/li\u003e
\u003cli\u003eImplementing more advanced AI techniques, such as reinforcement learning or genetic algorithms\u003c/li\u003e
\u003cli\u003eAdding additional features to the game, such as power-ups or obstacles, to make gameplay more varied and interesting.\u003c/li\u003e
\u003c/ul\u003e
`),$(".modal-title").html("Cliche, the origins in Unreal Engine"),$(".PortfolioImage").attr("src","/images/giphy.gif"),$(".modal-container").fadeIn(),$(".modal-container").scrollTop(0)}),$(".close").click(function(){document.body.style.overflow="auto",$(".modal-container").fadeOut()}),$(".modal-container").click(function(e){e.target==this&&(document.body.style.overflow="auto",$(".modal-container").fadeOut())})})</script><script>$(document).ready(function(){$(".blog-entry[data-blog-id='1002']").click(function(e){if(e.preventDefault(),document.body.style.overflow="hidden",$(".left-column").empty(),null){document.getElementById("blog-colums").className="two-columns";let e="";null.forEach(function(t){e+=`<img src="${t}" />`}),$(".left-column").html(e)}else document.getElementById("blog-colums").className="one-column";$(".blog-entry-content").html(`
\u003cdiv\u003e
  \u003cnav id=\u0022TableOfContents\u0022\u003e
  \u003cul\u003e
    \u003cli\u003e\u003ca href=\u0022#introduction\u0022\u003eIntroduction\u003c/a\u003e\u003c/li\u003e
    \u003cli\u003e\u003ca href=\u0022#setting-up-the-population-manager-script\u0022\u003eSetting up the population manager script\u003c/a\u003e\u003c/li\u003e
    \u003cli\u003e\u003ca href=\u0022#creating-the-population\u0022\u003eCreating the Population\u003c/a\u003e\u003c/li\u003e
    \u003cli\u003e\u003ca href=\u0022#breeding-the-population\u0022\u003eBreeding the Population\u003c/a\u003e\u003c/li\u003e
    \u003cli\u003e\u003ca href=\u0022#fine-tuning-the-genetic-algorithm\u0022\u003eFine-tuning the genetic algorithm\u003c/a\u003e\u003c/li\u003e
    \u003cli\u003e\u003ca href=\u0022#updating-the-population\u0022\u003eUpdating the Population\u003c/a\u003e\u003c/li\u003e
    \u003cli\u003e\u003ca href=\u0022#conclusion\u0022\u003eConclusion\u003c/a\u003e\u003c/li\u003e
  \u003c/ul\u003e
\u003c/nav\u003e
\u003c/div\u003e

\u003ch3 id=\u0022introduction\u0022\u003eIntroduction\u003c/h3\u003e
\u003cp\u003eGenetic algorithms are a powerful tool for finding solutions to complex problems. They work by simulating the process of natural selection, using a combination of mutation and crossover to create a new generation of solutions that is better than the previous generation. In this project, we will use genetic algorithms to create a maze walking solution in Unity. We will create a population of bots, each with its own unique DNA, and evolve that population over time until we have a group of bots that can successfully navigate a maze.\u003c/p\u003e
\u003ch3 id=\u0022setting-up-the-population-manager-script\u0022\u003eSetting up the population manager script\u003c/h3\u003e
\u003cp\u003eThe first thing we need to do is set up the link library at the top of the script. We\u0026rsquo;ll then declare public game objects for the bot prefab and starting position. Population size is set to 50, and a list is created to hold the population. Public static elapsed time and trial time variables are created, along with a GUI to print the generation count, how far the generation has run, and the population count.\u003c/p\u003e
\u003ch3 id=\u0022creating-the-population\u0022\u003eCreating the Population\u003c/h3\u003e
\u003cp\u003eThe start function loops through and creates the population by instantiating the bot prefab at the starting position and adding the bot to the population list. Each bot has a DNA component, which contains an array of floats representing the bot\u0026rsquo;s neural network weights. We use a simple neural network with three input nodes, two hidden nodes, and two output nodes to control the bot\u0026rsquo;s movement.\u003c/p\u003e
\u003ch3 id=\u0022breeding-the-population\u0022\u003eBreeding the Population\u003c/h3\u003e
\u003cp\u003eThe breed function creates an offspring from two parents, sets up the offspring\u0026rsquo;s brain, and mutates its DNA. We use a simple crossover algorithm to combine the parents\u0026rsquo; DNA and a mutation rate to randomly modify the DNA. Breed new population orders the population by the distance traveled and then breeds the top half with everyone else in the top half and adds the children to the population.\u003c/p\u003e
\u003ch3 id=\u0022fine-tuning-the-genetic-algorithm\u0022\u003eFine-tuning the genetic algorithm\u003c/h3\u003e
\u003cp\u003eThe fitness function is used to evaluate the performance of each bot in the population, and determine which individuals should be selected for breeding in the next generation. In this context, we use the distance traveled by the bot as the fitness score. We calculate the distance between the bot\u0026rsquo;s current position and the target position in the maze, and use this value to update the bot\u0026rsquo;s fitness score.\u003c/p\u003e
\u003ch3 id=\u0022updating-the-population\u0022\u003eUpdating the Population\u003c/h3\u003e
\u003cp\u003eThe update function ticks around for the elapsed time until it reaches the end of the trial time, brings the population, and starts all over again. We use Unity\u0026rsquo;s built-in coroutine feature to wait for a specified amount of time before restarting the trial. This allows us to evaluate each bot\u0026rsquo;s fitness over a fixed period of time, rather than simply measuring the distance traveled in a single frame.\u003c/p\u003e
\u003ch3 id=\u0022conclusion\u0022\u003eConclusion\u003c/h3\u003e
\u003cp\u003eIn conclusion, we\u0026rsquo;ve created a population manager in Unity for a maze walking solution using genetic algorithms. The code provides a good example of how to set up a population of bots, breed them, and evaluate their fitness in order to evolve a population that can successfully navigate a maze. We\u0026rsquo;ve also seen the importance of fitness functions in genetic algorithms, the use of lists in C# to manage data structures, and the value of good coding practices and testing your code. By experimenting with different parameters and fine-tuning our genetic algorithm, we can improve the quality of the solutions it generates and apply this knowledge to other complex problems.\u003c/p\u003e
`),$(".modal-title").html("Creating a Maze Walking with Genetic Algorithms"),$(".PortfolioImage").attr("src","/images/giphy.gif"),$(".modal-container").fadeIn(),$(".modal-container").scrollTop(0)}),$(".close").click(function(){document.body.style.overflow="auto",$(".modal-container").fadeOut()}),$(".modal-container").click(function(e){e.target==this&&(document.body.style.overflow="auto",$(".modal-container").fadeOut())})})</script><script>$(document).ready(function(){$(".blog-entry[data-blog-id='1010']").click(function(e){if(e.preventDefault(),document.body.style.overflow="hidden",$(".left-column").empty(),null){document.getElementById("blog-colums").className="two-columns";let e="";null.forEach(function(t){e+=`<img src="${t}" />`}),$(".left-column").html(e)}else document.getElementById("blog-colums").className="one-column";$(".blog-entry-content").html(`
\u003cdiv\u003e
  \u003cnav id=\u0022TableOfContents\u0022\u003e
  \u003cul\u003e
    \u003cli\u003e\u003ca href=\u0022#description\u0022\u003e\u003cstrong\u003eDescription:\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e
    \u003cli\u003e\u003ca href=\u0022#key-learnings\u0022\u003e\u003cstrong\u003eKey Learnings:\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e
    \u003cli\u003e\u003ca href=\u0022#tools-and-technologies-used\u0022\u003e\u003cstrong\u003eTools and Technologies Used:\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e
    \u003cli\u003e\u003ca href=\u0022#outcome\u0022\u003e\u003cstrong\u003eOutcome:\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e
    \u003cli\u003e\u003ca href=\u0022#future-improvements\u0022\u003e\u003cstrong\u003eFuture Improvements:\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e
  \u003c/ul\u003e
\u003c/nav\u003e
\u003c/div\u003e

\u003ch3 id=\u0022description\u0022\u003e\u003cstrong\u003eDescription:\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eIn this project, I created a population manager in Unity using genetic algorithms to navigate a maze. The project involved setting up a population of bots, breeding them, and evaluating their fitness in order to evolve a population that can successfully navigate a maze.\u003c/p\u003e
\u003ch3 id=\u0022key-learnings\u0022\u003e\u003cstrong\u003eKey Learnings:\u003c/strong\u003e\u003c/h3\u003e
\u003cul\u003e
\u003cli\u003eCreating a population manager in Unity using genetic algorithms\u003c/li\u003e
\u003cli\u003eImplementing fitness functions in genetic algorithms\u003c/li\u003e
\u003cli\u003eManaging data structures using lists in C#\u003c/li\u003e
\u003cli\u003eApplying good coding practices, such as commenting and using informative variable names\u003c/li\u003e
\u003cli\u003eTesting and experimenting with different parameters to fine-tune the genetic algorithm and improve the quality of the solutions it generates.\u003c/li\u003e
\u003c/ul\u003e
\u003c!-- raw HTML omitted --\u003e
\u003c!-- raw HTML omitted --\u003e
\u003ch3 id=\u0022tools-and-technologies-used\u0022\u003e\u003cstrong\u003eTools and Technologies Used:\u003c/strong\u003e\u003c/h3\u003e
\u003cul\u003e
\u003cli\u003eUnity game engine\u003c/li\u003e
\u003cli\u003eC# programming language\u003c/li\u003e
\u003c/ul\u003e
\u003ch3 id=\u0022outcome\u0022\u003e\u003cstrong\u003eOutcome:\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eThe project resulted in a working genetic algorithm that successfully navigated through a maze. It demonstrated my ability to apply genetic algorithms in game development, and my proficiency in using Unity and C# to implement complex solutions.\u003c/p\u003e
\u003ch3 id=\u0022future-improvements\u0022\u003e\u003cstrong\u003eFuture Improvements:\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eOne potential area for future improvement would be to explore different selection and mutation strategies to improve the performance of the genetic algorithm. Additionally, the project could be expanded to include more complex mazes or other challenges that require navigation and decision-making.\u003c/p\u003e
`),$(".modal-title").html("Creating Adventure land"),$(".PortfolioImage").attr("src","/images/giphy.gif"),$(".modal-container").fadeIn(),$(".modal-container").scrollTop(0)}),$(".close").click(function(){document.body.style.overflow="auto",$(".modal-container").fadeOut()}),$(".modal-container").click(function(e){e.target==this&&(document.body.style.overflow="auto",$(".modal-container").fadeOut())})})</script><script>$(document).ready(function(){$(".blog-entry[data-blog-id='1009']").click(function(e){if(e.preventDefault(),document.body.style.overflow="hidden",$(".left-column").empty(),null){document.getElementById("blog-colums").className="two-columns";let e="";null.forEach(function(t){e+=`<img src="${t}" />`}),$(".left-column").html(e)}else document.getElementById("blog-colums").className="one-column";$(".blog-entry-content").html(`
\u003cdiv\u003e
  \u003cnav id=\u0022TableOfContents\u0022\u003e
  \u003cul\u003e
    \u003cli\u003e\u003ca href=\u0022#description\u0022\u003e\u003cstrong\u003eDescription:\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e
    \u003cli\u003e\u003ca href=\u0022#key-learnings\u0022\u003e\u003cstrong\u003eKey Learnings:\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e
    \u003cli\u003e\u003ca href=\u0022#tools-and-technologies-used\u0022\u003e\u003cstrong\u003eTools and Technologies Used:\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e
    \u003cli\u003e\u003ca href=\u0022#outcome\u0022\u003e\u003cstrong\u003eOutcome:\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e
    \u003cli\u003e\u003ca href=\u0022#future-improvements\u0022\u003e\u003cstrong\u003eFuture Improvements:\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e
  \u003c/ul\u003e
\u003c/nav\u003e
\u003c/div\u003e

\u003ch3 id=\u0022description\u0022\u003e\u003cstrong\u003eDescription:\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eIn this project, I created a population manager in Unity using genetic algorithms to navigate a maze. The project involved setting up a population of bots, breeding them, and evaluating their fitness in order to evolve a population that can successfully navigate a maze.\u003c/p\u003e
\u003ch3 id=\u0022key-learnings\u0022\u003e\u003cstrong\u003eKey Learnings:\u003c/strong\u003e\u003c/h3\u003e
\u003cul\u003e
\u003cli\u003eCreating a population manager in Unity using genetic algorithms\u003c/li\u003e
\u003cli\u003eImplementing fitness functions in genetic algorithms\u003c/li\u003e
\u003cli\u003eManaging data structures using lists in C#\u003c/li\u003e
\u003cli\u003eApplying good coding practices, such as commenting and using informative variable names\u003c/li\u003e
\u003cli\u003eTesting and experimenting with different parameters to fine-tune the genetic algorithm and improve the quality of the solutions it generates.\u003c/li\u003e
\u003c/ul\u003e
\u003c!-- raw HTML omitted --\u003e
\u003c!-- raw HTML omitted --\u003e
\u003ch3 id=\u0022tools-and-technologies-used\u0022\u003e\u003cstrong\u003eTools and Technologies Used:\u003c/strong\u003e\u003c/h3\u003e
\u003cul\u003e
\u003cli\u003eUnity game engine\u003c/li\u003e
\u003cli\u003eC# programming language\u003c/li\u003e
\u003c/ul\u003e
\u003ch3 id=\u0022outcome\u0022\u003e\u003cstrong\u003eOutcome:\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eThe project resulted in a working genetic algorithm that successfully navigated through a maze. It demonstrated my ability to apply genetic algorithms in game development, and my proficiency in using Unity and C# to implement complex solutions.\u003c/p\u003e
\u003ch3 id=\u0022future-improvements\u0022\u003e\u003cstrong\u003eFuture Improvements:\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eOne potential area for future improvement would be to explore different selection and mutation strategies to improve the performance of the genetic algorithm. Additionally, the project could be expanded to include more complex mazes or other challenges that require navigation and decision-making.\u003c/p\u003e
`),$(".modal-title").html("Creating Alien invasion with Stable diffusion"),$(".PortfolioImage").attr("src","/images/giphy.gif"),$(".modal-container").fadeIn(),$(".modal-container").scrollTop(0)}),$(".close").click(function(){document.body.style.overflow="auto",$(".modal-container").fadeOut()}),$(".modal-container").click(function(e){e.target==this&&(document.body.style.overflow="auto",$(".modal-container").fadeOut())})})</script><script>$(document).ready(function(){$(".blog-entry[data-blog-id='1008']").click(function(e){if(e.preventDefault(),document.body.style.overflow="hidden",$(".left-column").empty(),null){document.getElementById("blog-colums").className="two-columns";let e="";null.forEach(function(t){e+=`<img src="${t}" />`}),$(".left-column").html(e)}else document.getElementById("blog-colums").className="one-column";$(".blog-entry-content").html(`
\u003cdiv\u003e
  \u003cnav id=\u0022TableOfContents\u0022\u003e
  \u003cul\u003e
    \u003cli\u003e\u003ca href=\u0022#description\u0022\u003e\u003cstrong\u003eDescription:\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e
    \u003cli\u003e\u003ca href=\u0022#key-learnings\u0022\u003e\u003cstrong\u003eKey Learnings:\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e
    \u003cli\u003e\u003ca href=\u0022#tools-and-technologies-used\u0022\u003e\u003cstrong\u003eTools and Technologies Used:\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e
    \u003cli\u003e\u003ca href=\u0022#outcome\u0022\u003e\u003cstrong\u003eOutcome:\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e
    \u003cli\u003e\u003ca href=\u0022#future-improvements\u0022\u003e\u003cstrong\u003eFuture Improvements:\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e
  \u003c/ul\u003e
\u003c/nav\u003e
\u003c/div\u003e

\u003ch3 id=\u0022description\u0022\u003e\u003cstrong\u003eDescription:\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eIn this project, I created a population manager in Unity using genetic algorithms to navigate a maze. The project involved setting up a population of bots, breeding them, and evaluating their fitness in order to evolve a population that can successfully navigate a maze.\u003c/p\u003e
\u003ch3 id=\u0022key-learnings\u0022\u003e\u003cstrong\u003eKey Learnings:\u003c/strong\u003e\u003c/h3\u003e
\u003cul\u003e
\u003cli\u003eCreating a population manager in Unity using genetic algorithms\u003c/li\u003e
\u003cli\u003eImplementing fitness functions in genetic algorithms\u003c/li\u003e
\u003cli\u003eManaging data structures using lists in C#\u003c/li\u003e
\u003cli\u003eApplying good coding practices, such as commenting and using informative variable names\u003c/li\u003e
\u003cli\u003eTesting and experimenting with different parameters to fine-tune the genetic algorithm and improve the quality of the solutions it generates.\u003c/li\u003e
\u003c/ul\u003e
\u003c!-- raw HTML omitted --\u003e
\u003c!-- raw HTML omitted --\u003e
\u003ch3 id=\u0022tools-and-technologies-used\u0022\u003e\u003cstrong\u003eTools and Technologies Used:\u003c/strong\u003e\u003c/h3\u003e
\u003cul\u003e
\u003cli\u003eUnity game engine\u003c/li\u003e
\u003cli\u003eC# programming language\u003c/li\u003e
\u003c/ul\u003e
\u003ch3 id=\u0022outcome\u0022\u003e\u003cstrong\u003eOutcome:\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eThe project resulted in a working genetic algorithm that successfully navigated through a maze. It demonstrated my ability to apply genetic algorithms in game development, and my proficiency in using Unity and C# to implement complex solutions.\u003c/p\u003e
\u003ch3 id=\u0022future-improvements\u0022\u003e\u003cstrong\u003eFuture Improvements:\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eOne potential area for future improvement would be to explore different selection and mutation strategies to improve the performance of the genetic algorithm. Additionally, the project could be expanded to include more complex mazes or other challenges that require navigation and decision-making.\u003c/p\u003e
`),$(".modal-title").html("Creating Alien ranger with Stable diffusion"),$(".PortfolioImage").attr("src","/images/giphy.gif"),$(".modal-container").fadeIn(),$(".modal-container").scrollTop(0)}),$(".close").click(function(){document.body.style.overflow="auto",$(".modal-container").fadeOut()}),$(".modal-container").click(function(e){e.target==this&&(document.body.style.overflow="auto",$(".modal-container").fadeOut())})})</script><script>$(document).ready(function(){$(".blog-entry[data-blog-id='1006']").click(function(e){if(e.preventDefault(),document.body.style.overflow="hidden",$(".left-column").empty(),null){document.getElementById("blog-colums").className="two-columns";let e="";null.forEach(function(t){e+=`<img src="${t}" />`}),$(".left-column").html(e)}else document.getElementById("blog-colums").className="one-column";$(".blog-entry-content").html(`
\u003cdiv\u003e
  \u003cnav id=\u0022TableOfContents\u0022\u003e
  \u003cul\u003e
    \u003cli\u003e\u003ca href=\u0022#description\u0022\u003e\u003cstrong\u003eDescription:\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e
    \u003cli\u003e\u003ca href=\u0022#key-learnings\u0022\u003e\u003cstrong\u003eKey Learnings:\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e
    \u003cli\u003e\u003ca href=\u0022#tools-and-technologies-used\u0022\u003e\u003cstrong\u003eTools and Technologies Used:\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e
    \u003cli\u003e\u003ca href=\u0022#outcome\u0022\u003e\u003cstrong\u003eOutcome:\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e
    \u003cli\u003e\u003ca href=\u0022#future-improvements\u0022\u003e\u003cstrong\u003eFuture Improvements:\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e
  \u003c/ul\u003e
\u003c/nav\u003e
\u003c/div\u003e

\u003ch3 id=\u0022description\u0022\u003e\u003cstrong\u003eDescription:\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eIn this project, I created a population manager in Unity using genetic algorithms to navigate a maze. The project involved setting up a population of bots, breeding them, and evaluating their fitness in order to evolve a population that can successfully navigate a maze.\u003c/p\u003e
\u003ch3 id=\u0022key-learnings\u0022\u003e\u003cstrong\u003eKey Learnings:\u003c/strong\u003e\u003c/h3\u003e
\u003cul\u003e
\u003cli\u003eCreating a population manager in Unity using genetic algorithms\u003c/li\u003e
\u003cli\u003eImplementing fitness functions in genetic algorithms\u003c/li\u003e
\u003cli\u003eManaging data structures using lists in C#\u003c/li\u003e
\u003cli\u003eApplying good coding practices, such as commenting and using informative variable names\u003c/li\u003e
\u003cli\u003eTesting and experimenting with different parameters to fine-tune the genetic algorithm and improve the quality of the solutions it generates.\u003c/li\u003e
\u003c/ul\u003e
\u003c!-- raw HTML omitted --\u003e
\u003c!-- raw HTML omitted --\u003e
\u003ch3 id=\u0022tools-and-technologies-used\u0022\u003e\u003cstrong\u003eTools and Technologies Used:\u003c/strong\u003e\u003c/h3\u003e
\u003cul\u003e
\u003cli\u003eUnity game engine\u003c/li\u003e
\u003cli\u003eC# programming language\u003c/li\u003e
\u003c/ul\u003e
\u003ch3 id=\u0022outcome\u0022\u003e\u003cstrong\u003eOutcome:\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eThe project resulted in a working genetic algorithm that successfully navigated through a maze. It demonstrated my ability to apply genetic algorithms in game development, and my proficiency in using Unity and C# to implement complex solutions.\u003c/p\u003e
\u003ch3 id=\u0022future-improvements\u0022\u003e\u003cstrong\u003eFuture Improvements:\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eOne potential area for future improvement would be to explore different selection and mutation strategies to improve the performance of the genetic algorithm. Additionally, the project could be expanded to include more complex mazes or other challenges that require navigation and decision-making.\u003c/p\u003e
`),$(".modal-title").html("Creating catch the lion"),$(".PortfolioImage").attr("src","/images/giphy.gif"),$(".modal-container").fadeIn(),$(".modal-container").scrollTop(0)}),$(".close").click(function(){document.body.style.overflow="auto",$(".modal-container").fadeOut()}),$(".modal-container").click(function(e){e.target==this&&(document.body.style.overflow="auto",$(".modal-container").fadeOut())})})</script><script>$(document).ready(function(){$(".blog-entry[data-blog-id='1011']").click(function(e){if(e.preventDefault(),document.body.style.overflow="hidden",$(".left-column").empty(),null){document.getElementById("blog-colums").className="two-columns";let e="";null.forEach(function(t){e+=`<img src="${t}" />`}),$(".left-column").html(e)}else document.getElementById("blog-colums").className="one-column";$(".blog-entry-content").html(`
\u003cdiv\u003e
  \u003cnav id=\u0022TableOfContents\u0022\u003e
  \u003cul\u003e
    \u003cli\u003e\u003ca href=\u0022#description\u0022\u003e\u003cstrong\u003eDescription:\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e
    \u003cli\u003e\u003ca href=\u0022#key-learnings\u0022\u003e\u003cstrong\u003eKey Learnings:\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e
    \u003cli\u003e\u003ca href=\u0022#tools-and-technologies-used\u0022\u003e\u003cstrong\u003eTools and Technologies Used:\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e
    \u003cli\u003e\u003ca href=\u0022#outcome\u0022\u003e\u003cstrong\u003eOutcome:\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e
    \u003cli\u003e\u003ca href=\u0022#future-improvements\u0022\u003e\u003cstrong\u003eFuture Improvements:\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e
  \u003c/ul\u003e
\u003c/nav\u003e
\u003c/div\u003e

\u003ch3 id=\u0022description\u0022\u003e\u003cstrong\u003eDescription:\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eIn this project, I created a population manager in Unity using genetic algorithms to navigate a maze. The project involved setting up a population of bots, breeding them, and evaluating their fitness in order to evolve a population that can successfully navigate a maze.\u003c/p\u003e
\u003ch3 id=\u0022key-learnings\u0022\u003e\u003cstrong\u003eKey Learnings:\u003c/strong\u003e\u003c/h3\u003e
\u003cul\u003e
\u003cli\u003eCreating a population manager in Unity using genetic algorithms\u003c/li\u003e
\u003cli\u003eImplementing fitness functions in genetic algorithms\u003c/li\u003e
\u003cli\u003eManaging data structures using lists in C#\u003c/li\u003e
\u003cli\u003eApplying good coding practices, such as commenting and using informative variable names\u003c/li\u003e
\u003cli\u003eTesting and experimenting with different parameters to fine-tune the genetic algorithm and improve the quality of the solutions it generates.\u003c/li\u003e
\u003c/ul\u003e
\u003c!-- raw HTML omitted --\u003e
\u003c!-- raw HTML omitted --\u003e
\u003ch3 id=\u0022tools-and-technologies-used\u0022\u003e\u003cstrong\u003eTools and Technologies Used:\u003c/strong\u003e\u003c/h3\u003e
\u003cul\u003e
\u003cli\u003eUnity game engine\u003c/li\u003e
\u003cli\u003eC# programming language\u003c/li\u003e
\u003c/ul\u003e
\u003ch3 id=\u0022outcome\u0022\u003e\u003cstrong\u003eOutcome:\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eThe project resulted in a working genetic algorithm that successfully navigated through a maze. It demonstrated my ability to apply genetic algorithms in game development, and my proficiency in using Unity and C# to implement complex solutions.\u003c/p\u003e
\u003ch3 id=\u0022future-improvements\u0022\u003e\u003cstrong\u003eFuture Improvements:\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eOne potential area for future improvement would be to explore different selection and mutation strategies to improve the performance of the genetic algorithm. Additionally, the project could be expanded to include more complex mazes or other challenges that require navigation and decision-making.\u003c/p\u003e
`),$(".modal-title").html("Creating Cliche, the origins in Unreal Engine"),$(".PortfolioImage").attr("src","/images/giphy.gif"),$(".modal-container").fadeIn(),$(".modal-container").scrollTop(0)}),$(".close").click(function(){document.body.style.overflow="auto",$(".modal-container").fadeOut()}),$(".modal-container").click(function(e){e.target==this&&(document.body.style.overflow="auto",$(".modal-container").fadeOut())})})</script><script>$(document).ready(function(){$(".blog-entry[data-blog-id='1012']").click(function(e){if(e.preventDefault(),document.body.style.overflow="hidden",$(".left-column").empty(),null){document.getElementById("blog-colums").className="two-columns";let e="";null.forEach(function(t){e+=`<img src="${t}" />`}),$(".left-column").html(e)}else document.getElementById("blog-colums").className="one-column";$(".blog-entry-content").html(`
\u003cdiv\u003e
  \u003cnav id=\u0022TableOfContents\u0022\u003e
  \u003cul\u003e
    \u003cli\u003e\u003ca href=\u0022#description\u0022\u003e\u003cstrong\u003eDescription:\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e
    \u003cli\u003e\u003ca href=\u0022#key-learnings\u0022\u003e\u003cstrong\u003eKey Learnings:\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e
    \u003cli\u003e\u003ca href=\u0022#tools-and-technologies-used\u0022\u003e\u003cstrong\u003eTools and Technologies Used:\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e
    \u003cli\u003e\u003ca href=\u0022#outcome\u0022\u003e\u003cstrong\u003eOutcome:\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e
    \u003cli\u003e\u003ca href=\u0022#future-improvements\u0022\u003e\u003cstrong\u003eFuture Improvements:\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e
  \u003c/ul\u003e
\u003c/nav\u003e
\u003c/div\u003e

\u003ch3 id=\u0022description\u0022\u003e\u003cstrong\u003eDescription:\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eIn this project, I created a population manager in Unity using genetic algorithms to navigate a maze. The project involved setting up a population of bots, breeding them, and evaluating their fitness in order to evolve a population that can successfully navigate a maze.\u003c/p\u003e
\u003ch3 id=\u0022key-learnings\u0022\u003e\u003cstrong\u003eKey Learnings:\u003c/strong\u003e\u003c/h3\u003e
\u003cul\u003e
\u003cli\u003eCreating a population manager in Unity using genetic algorithms\u003c/li\u003e
\u003cli\u003eImplementing fitness functions in genetic algorithms\u003c/li\u003e
\u003cli\u003eManaging data structures using lists in C#\u003c/li\u003e
\u003cli\u003eApplying good coding practices, such as commenting and using informative variable names\u003c/li\u003e
\u003cli\u003eTesting and experimenting with different parameters to fine-tune the genetic algorithm and improve the quality of the solutions it generates.\u003c/li\u003e
\u003c/ul\u003e
\u003c!-- raw HTML omitted --\u003e
\u003c!-- raw HTML omitted --\u003e
\u003ch3 id=\u0022tools-and-technologies-used\u0022\u003e\u003cstrong\u003eTools and Technologies Used:\u003c/strong\u003e\u003c/h3\u003e
\u003cul\u003e
\u003cli\u003eUnity game engine\u003c/li\u003e
\u003cli\u003eC# programming language\u003c/li\u003e
\u003c/ul\u003e
\u003ch3 id=\u0022outcome\u0022\u003e\u003cstrong\u003eOutcome:\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eThe project resulted in a working genetic algorithm that successfully navigated through a maze. It demonstrated my ability to apply genetic algorithms in game development, and my proficiency in using Unity and C# to implement complex solutions.\u003c/p\u003e
\u003ch3 id=\u0022future-improvements\u0022\u003e\u003cstrong\u003eFuture Improvements:\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eOne potential area for future improvement would be to explore different selection and mutation strategies to improve the performance of the genetic algorithm. Additionally, the project could be expanded to include more complex mazes or other challenges that require navigation and decision-making.\u003c/p\u003e
`),$(".modal-title").html("Creating Lost in the forest in Unreal Engine"),$(".PortfolioImage").attr("src","/images/giphy.gif"),$(".modal-container").fadeIn(),$(".modal-container").scrollTop(0)}),$(".close").click(function(){document.body.style.overflow="auto",$(".modal-container").fadeOut()}),$(".modal-container").click(function(e){e.target==this&&(document.body.style.overflow="auto",$(".modal-container").fadeOut())})})</script><script>$(document).ready(function(){$(".blog-entry[data-blog-id='1004']").click(function(e){if(e.preventDefault(),document.body.style.overflow="hidden",$(".left-column").empty(),null){document.getElementById("blog-colums").className="two-columns";let e="";null.forEach(function(t){e+=`<img src="${t}" />`}),$(".left-column").html(e)}else document.getElementById("blog-colums").className="one-column";$(".blog-entry-content").html(`
\u003cdiv\u003e
  \u003cnav id=\u0022TableOfContents\u0022\u003e
  \u003cul\u003e
    \u003cli\u003e\u003ca href=\u0022#introduction\u0022\u003e\u003cstrong\u003eIntroduction\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e
    \u003cli\u003e\u003ca href=\u0022#genetic-algorithms-and-their-applications\u0022\u003e\u003cstrong\u003eGenetic Algorithms and their Applications\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e
    \u003cli\u003e\u003ca href=\u0022#creating-a-population-of-bots-using-genetic-algorithms\u0022\u003e\u003cstrong\u003eCreating a population of bots using genetic algorithms\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e
    \u003cli\u003e\u003ca href=\u0022#setting-up-the-population-manager\u0022\u003e\u003cstrong\u003eSetting up the population manager\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e
    \u003cli\u003e\u003ca href=\u0022#using-distance-as-fitness-function\u0022\u003e\u003cstrong\u003eUsing distance as fitness function\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e
    \u003cli\u003e\u003ca href=\u0022#conclusion\u0022\u003e\u003cstrong\u003eConclusion\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e
  \u003c/ul\u003e
\u003c/nav\u003e
\u003c/div\u003e

\u003ch3 id=\u0022introduction\u0022\u003e\u003cstrong\u003eIntroduction\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eThe field of artificial intelligence has been rapidly evolving, with new technologies and algorithms being developed every day. In the world of game development, creating bots that can move effectively and adapt to different scenarios can be a challenging task. Genetic algorithms offer a powerful solution to this problem by using evolutionary principles to train bots to perform specific tasks. In this blog, we will discuss how genetic algorithms can be used to create movement for bots in Unity game environment.\u003c/p\u003e
\u003ch3 id=\u0022genetic-algorithms-and-their-applications\u0022\u003e\u003cstrong\u003eGenetic Algorithms and their Applications\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eGenetic algorithms are a type of optimization algorithm that are inspired by the process of natural selection. They work by creating a population of potential solutions and then evolving them over several generations to find the best solution. Genetic algorithms have a wide range of applications, including machine learning, optimization, and robotics.\u003c/p\u003e
\u003ch3 id=\u0022creating-a-population-of-bots-using-genetic-algorithms\u0022\u003e\u003cstrong\u003eCreating a population of bots using genetic algorithms\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eTo create a population of bots, we need to define a gene sequence that represents the bots\u0026rsquo; behavior. In this scenario, we will use the Ethan Walker Unity package to create a population of bots that must survive on a long, narrow beam. We will create a DNA code that will be used by the bot and set random values in the gene when it\u0026rsquo;s initialized. We will also use integer values to set the maximum value of the gene and use the set method to set the integer value at a particular position for the gene sequence. Finally, we will use the combine method to split the sequence from the parent and put them back together.\u003c/p\u003e
\u003ch3 id=\u0022setting-up-the-population-manager\u0022\u003e\u003cstrong\u003eSetting up the population manager\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eThe population manager class is responsible for creating a large population of bots for training using genetic algorithms. We will create this class with a bot prefab, population size, population list, elapsed time, trial time, and generation. We will use the Unity GUI system to display stats about the current generation on the screen. We will also create an initial population of bots using a for loop and set the position of each bot to a random location within a certain range. To prevent collisions between bots, which could interfere with the genetic algorithm\u0026rsquo;s training, we will implement a collision detection system.\u003c/p\u003e
\u003ch3 id=\u0022using-distance-as-fitness-function\u0022\u003e\u003cstrong\u003eUsing distance as fitness function\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eIn this scenario, we will use a distance value to calculate fitness rather than how long the character has been alive for. This way, we can train the bots not only to stay on the platform but also to encourage them to move along the platform rather than just jumping up and down or standing still. We will add a distance traveled value to the brain class and update it in the if alive in the fixed update for each agent. This value will be used in the breed new population code to determine fitness, instead of using how long the agent has been alive. This approach allows for a more effective way to train the bots to move along the platform and stay alive.\u003c/p\u003e
\u003ch3 id=\u0022conclusion\u0022\u003e\u003cstrong\u003eConclusion\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eGenetic algorithms are a powerful technique that can be used to solve a wide range of problems, including creating movement for bots in a Unity game environment. we have demonstrated how genetic algorithms can be used to train bots to perform a specific task for example by using distance as a fitness function. The applications of genetic algorithms are endless, and they will continue to play an important role in the field of artificial intelligence.\u003c/p\u003e
`),$(".modal-title").html("Creating movement for bots with genetic algorithms"),$(".PortfolioImage").attr("src","/images/giphy.gif"),$(".modal-container").fadeIn(),$(".modal-container").scrollTop(0)}),$(".close").click(function(){document.body.style.overflow="auto",$(".modal-container").fadeOut()}),$(".modal-container").click(function(e){e.target==this&&(document.body.style.overflow="auto",$(".modal-container").fadeOut())})})</script><script>$(document).ready(function(){$(".blog-entry[data-blog-id='1005']").click(function(e){if(e.preventDefault(),document.body.style.overflow="hidden",$(".left-column").empty(),null){document.getElementById("blog-colums").className="two-columns";let e="";null.forEach(function(t){e+=`<img src="${t}" />`}),$(".left-column").html(e)}else document.getElementById("blog-colums").className="one-column";$(".blog-entry-content").html(`
\u003cdiv\u003e
  \u003cnav id=\u0022TableOfContents\u0022\u003e
  \u003cul\u003e
    \u003cli\u003e\u003ca href=\u0022#description\u0022\u003e\u003cstrong\u003eDescription:\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e
    \u003cli\u003e\u003ca href=\u0022#key-learnings\u0022\u003e\u003cstrong\u003eKey Learnings:\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e
    \u003cli\u003e\u003ca href=\u0022#tools-and-technologies-used\u0022\u003e\u003cstrong\u003eTools and Technologies Used:\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e
    \u003cli\u003e\u003ca href=\u0022#outcome\u0022\u003e\u003cstrong\u003eOutcome:\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e
    \u003cli\u003e\u003ca href=\u0022#future-improvements\u0022\u003e\u003cstrong\u003eFuture Improvements:\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e
  \u003c/ul\u003e
\u003c/nav\u003e
\u003c/div\u003e

\u003ch3 id=\u0022description\u0022\u003e\u003cstrong\u003eDescription:\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eIn this project, I created a population manager in Unity using genetic algorithms to navigate a maze. The project involved setting up a population of bots, breeding them, and evaluating their fitness in order to evolve a population that can successfully navigate a maze.\u003c/p\u003e
\u003ch3 id=\u0022key-learnings\u0022\u003e\u003cstrong\u003eKey Learnings:\u003c/strong\u003e\u003c/h3\u003e
\u003cul\u003e
\u003cli\u003eCreating a population manager in Unity using genetic algorithms\u003c/li\u003e
\u003cli\u003eImplementing fitness functions in genetic algorithms\u003c/li\u003e
\u003cli\u003eManaging data structures using lists in C#\u003c/li\u003e
\u003cli\u003eApplying good coding practices, such as commenting and using informative variable names\u003c/li\u003e
\u003cli\u003eTesting and experimenting with different parameters to fine-tune the genetic algorithm and improve the quality of the solutions it generates.\u003c/li\u003e
\u003c/ul\u003e
\u003c!-- raw HTML omitted --\u003e
\u003c!-- raw HTML omitted --\u003e
\u003ch3 id=\u0022tools-and-technologies-used\u0022\u003e\u003cstrong\u003eTools and Technologies Used:\u003c/strong\u003e\u003c/h3\u003e
\u003cul\u003e
\u003cli\u003eUnity game engine\u003c/li\u003e
\u003cli\u003eC# programming language\u003c/li\u003e
\u003c/ul\u003e
\u003ch3 id=\u0022outcome\u0022\u003e\u003cstrong\u003eOutcome:\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eThe project resulted in a working genetic algorithm that successfully navigated through a maze. It demonstrated my ability to apply genetic algorithms in game development, and my proficiency in using Unity and C# to implement complex solutions.\u003c/p\u003e
\u003ch3 id=\u0022future-improvements\u0022\u003e\u003cstrong\u003eFuture Improvements:\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eOne potential area for future improvement would be to explore different selection and mutation strategies to improve the performance of the genetic algorithm. Additionally, the project could be expanded to include more complex mazes or other challenges that require navigation and decision-making.\u003c/p\u003e
`),$(".modal-title").html("Creating pong enemy AI"),$(".PortfolioImage").attr("src","/images/giphy.gif"),$(".modal-container").fadeIn(),$(".modal-container").scrollTop(0)}),$(".close").click(function(){document.body.style.overflow="auto",$(".modal-container").fadeOut()}),$(".modal-container").click(function(e){e.target==this&&(document.body.style.overflow="auto",$(".modal-container").fadeOut())})})</script><script>$(document).ready(function(){$(".blog-entry[data-blog-id='1007']").click(function(e){if(e.preventDefault(),document.body.style.overflow="hidden",$(".left-column").empty(),null){document.getElementById("blog-colums").className="two-columns";let e="";null.forEach(function(t){e+=`<img src="${t}" />`}),$(".left-column").html(e)}else document.getElementById("blog-colums").className="one-column";$(".blog-entry-content").html(`
\u003cdiv\u003e
  \u003cnav id=\u0022TableOfContents\u0022\u003e
  \u003cul\u003e
    \u003cli\u003e\u003ca href=\u0022#description\u0022\u003e\u003cstrong\u003eDescription:\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e
    \u003cli\u003e\u003ca href=\u0022#key-learnings\u0022\u003e\u003cstrong\u003eKey Learnings:\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e
    \u003cli\u003e\u003ca href=\u0022#tools-and-technologies-used\u0022\u003e\u003cstrong\u003eTools and Technologies Used:\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e
    \u003cli\u003e\u003ca href=\u0022#outcome\u0022\u003e\u003cstrong\u003eOutcome:\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e
    \u003cli\u003e\u003ca href=\u0022#future-improvements\u0022\u003e\u003cstrong\u003eFuture Improvements:\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e
  \u003c/ul\u003e
\u003c/nav\u003e
\u003c/div\u003e

\u003ch3 id=\u0022description\u0022\u003e\u003cstrong\u003eDescription:\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eIn this project, I created a population manager in Unity using genetic algorithms to navigate a maze. The project involved setting up a population of bots, breeding them, and evaluating their fitness in order to evolve a population that can successfully navigate a maze.\u003c/p\u003e
\u003ch3 id=\u0022key-learnings\u0022\u003e\u003cstrong\u003eKey Learnings:\u003c/strong\u003e\u003c/h3\u003e
\u003cul\u003e
\u003cli\u003eCreating a population manager in Unity using genetic algorithms\u003c/li\u003e
\u003cli\u003eImplementing fitness functions in genetic algorithms\u003c/li\u003e
\u003cli\u003eManaging data structures using lists in C#\u003c/li\u003e
\u003cli\u003eApplying good coding practices, such as commenting and using informative variable names\u003c/li\u003e
\u003cli\u003eTesting and experimenting with different parameters to fine-tune the genetic algorithm and improve the quality of the solutions it generates.\u003c/li\u003e
\u003c/ul\u003e
\u003c!-- raw HTML omitted --\u003e
\u003c!-- raw HTML omitted --\u003e
\u003ch3 id=\u0022tools-and-technologies-used\u0022\u003e\u003cstrong\u003eTools and Technologies Used:\u003c/strong\u003e\u003c/h3\u003e
\u003cul\u003e
\u003cli\u003eUnity game engine\u003c/li\u003e
\u003cli\u003eC# programming language\u003c/li\u003e
\u003c/ul\u003e
\u003ch3 id=\u0022outcome\u0022\u003e\u003cstrong\u003eOutcome:\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eThe project resulted in a working genetic algorithm that successfully navigated through a maze. It demonstrated my ability to apply genetic algorithms in game development, and my proficiency in using Unity and C# to implement complex solutions.\u003c/p\u003e
\u003ch3 id=\u0022future-improvements\u0022\u003e\u003cstrong\u003eFuture Improvements:\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eOne potential area for future improvement would be to explore different selection and mutation strategies to improve the performance of the genetic algorithm. Additionally, the project could be expanded to include more complex mazes or other challenges that require navigation and decision-making.\u003c/p\u003e
`),$(".modal-title").html("Creating sea monsters assault"),$(".PortfolioImage").attr("src","/images/giphy.gif"),$(".modal-container").fadeIn(),$(".modal-container").scrollTop(0)}),$(".close").click(function(){document.body.style.overflow="auto",$(".modal-container").fadeOut()}),$(".modal-container").click(function(e){e.target==this&&(document.body.style.overflow="auto",$(".modal-container").fadeOut())})})</script><script>$(document).ready(function(){$(".blog-entry[data-blog-id='3']").click(function(e){if(e.preventDefault(),document.body.style.overflow="hidden",$(".left-column").empty(),null){document.getElementById("blog-colums").className="two-columns";let e="";null.forEach(function(t){e+=`<img src="${t}" />`}),$(".left-column").html(e)}else document.getElementById("blog-colums").className="one-column";$(".blog-entry-content").html(`\u003ch3 id=\u0022description\u0022\u003e\u003cstrong\u003eDescription:\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eThis project is a 2D game inspired by Flappy Bird, where the player controls a bird to navigate through obstacles. However, instead of controlling the bird manually, the game uses genetic algorithms to train the birds to navigate through the obstacles on their own. Each bird has its own gene sequence, and the birds that get the farthest through the obstacle course are considered the fittest and bred together.\u003c/p\u003e
\u003ch3 id=\u0022key-skills-demonstrated\u0022\u003e\u003cstrong\u003eKey Skills Demonstrated:\u003c/strong\u003e\u003c/h3\u003e
\u003cul\u003e
\u003cli\u003eMachine learning using genetic algorithms\u003c/li\u003e
\u003cli\u003e2D collision detection and raycasting in Unity\u003c/li\u003e
\u003cli\u003eFitness function evaluation and optimization\u003c/li\u003e
\u003cli\u003eObject-oriented programming principles\u003c/li\u003e
\u003cli\u003eDebugging and visualization using Unity\u0026rsquo;s tools\u003c/li\u003e
\u003c/ul\u003e
\u003ch3 id=\u0022tools-and-technologies-used\u0022\u003e\u003cstrong\u003eTools and Technologies Used:\u003c/strong\u003e\u003c/h3\u003e
\u003cul\u003e
\u003cli\u003eUnity game engine\u003c/li\u003e
\u003cli\u003eC# programming language\u003c/li\u003e
\u003c/ul\u003e
\u003ch3 id=\u0022details\u0022\u003e\u003cstrong\u003eDetails:\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eThe game uses 2D colliders and raycasting in Unity to detect collisions with objects in a 2D space. The fitness function is used to evaluate the performance of each bird in the population, which is a crucial concept in genetic algorithms and machine learning in general. The code is written in an object-oriented style, with different classes for the bird, population, and genetic algorithm. Debugging is done using Unity\u0026rsquo;s tools to visualize the raycasts and collisions.\u003c/p\u003e
\u003ch3 id=\u0022outcome\u0022\u003e\u003cstrong\u003eOutcome:\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eThe game successfully trains the birds to navigate through the obstacle course without crashing into walls using genetic algorithms. This project demonstrates the application of genetic algorithms in game development and how it can be used for machine learning tasks. It also showcases the use of 2D collider and raycasting in Unity, object-oriented programming, and debugging using Unity\u0026rsquo;s tools.\u003c/p\u003e
\u003ch3 id=\u0022future-improvements\u0022\u003e\u003cstrong\u003eFuture Improvements:\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eIn the future, I plan to add more obstacles and challenges to the game to make it more challenging. I also plan to implement a neural network to replace the current gene sequence and improve the performance of the birds. Additionally, I plan to optimize the code to run more efficiently and to improve the overall user experience of the game.\u003c/p\u003e
`),$(".modal-title").html("Genetic Algorithm Flappy Bird Game"),$(".PortfolioImage").attr("src","/images/giphy.gif"),$(".modal-container").fadeIn(),$(".modal-container").scrollTop(0)}),$(".close").click(function(){document.body.style.overflow="auto",$(".modal-container").fadeOut()}),$(".modal-container").click(function(e){e.target==this&&(document.body.style.overflow="auto",$(".modal-container").fadeOut())})})</script><script>$(document).ready(function(){$(".blog-entry[data-blog-id='1003']").click(function(e){if(e.preventDefault(),document.body.style.overflow="hidden",$(".left-column").empty(),null){document.getElementById("blog-colums").className="two-columns";let e="";null.forEach(function(t){e+=`<img src="${t}" />`}),$(".left-column").html(e)}else document.getElementById("blog-colums").className="one-column";$(".blog-entry-content").html(`
\u003cdiv\u003e
  \u003cnav id=\u0022TableOfContents\u0022\u003e
  \u003cul\u003e
    \u003cli\u003e\u003ca href=\u0022#introduction\u0022\u003e\u003cstrong\u003eIntroduction\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e
    \u003cli\u003e\u003ca href=\u0022#what-are-genetic-algorithms\u0022\u003e\u003cstrong\u003eWhat are Genetic Algorithms?\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e
    \u003cli\u003e\u003ca href=\u0022#setting-up-the-obstacle-course\u0022\u003e\u003cstrong\u003eSetting up the Obstacle Course\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e
    \u003cli\u003e\u003ca href=\u0022#using-2d-colliders-and-raycasting-in-unity\u0022\u003e\u003cstrong\u003eUsing 2D Colliders and Raycasting in Unity\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e
    \u003cli\u003e\u003ca href=\u0022#creating-the-fitness-function\u0022\u003e\u003cstrong\u003eCreating the Fitness Function\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e
    \u003cli\u003e\u003ca href=\u0022#debugging-tools-in-unity\u0022\u003e\u003cstrong\u003eDebugging Tools in Unity\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e
    \u003cli\u003e\u003ca href=\u0022#object-oriented-programming-in-unity\u0022\u003e\u003cstrong\u003eObject-Oriented Programming in Unity\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e
    \u003cli\u003e\u003ca href=\u0022#conclusion\u0022\u003e\u003cstrong\u003eConclusion\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e
  \u003c/ul\u003e
\u003c/nav\u003e
\u003c/div\u003e

\u003ch3 id=\u0022introduction\u0022\u003e\u003cstrong\u003eIntroduction\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eIn this blog, we will explore how to use genetic algorithms to train a bird to navigate through an obstacle course without crashing into walls. We will use Unity to create a 2D game inspired by Flappy Birds.\u003c/p\u003e
\u003ch3 id=\u0022what-are-genetic-algorithms\u0022\u003e\u003cstrong\u003eWhat are Genetic Algorithms?\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eGenetic algorithms are a type of machine learning that is based on the principles of natural selection. In genetic algorithms, we create a population of potential solutions, and then we evaluate the fitness of each solution based on a fitness function. The fittest solutions are then selected to reproduce, and their genetic material is combined to create new solutions. This process is repeated over multiple generations, with the hope that the population will evolve to find the optimal solution to the problem.\u003c/p\u003e
\u003ch3 id=\u0022setting-up-the-obstacle-course\u0022\u003e\u003cstrong\u003eSetting up the Obstacle Course\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eTo set up the obstacle course, we use sprites and box colliders in Unity. Each sprite is given a tag to differentiate between top, bottom, dead, up wall, and down wall. The birds must navigate through the course without hitting any walls. The goal is for the birds to get through the obstacle course, and the fitness value is based on the distance traveled by the birds.\u003c/p\u003e
\u003ch3 id=\u0022using-2d-colliders-and-raycasting-in-unity\u0022\u003e\u003cstrong\u003eUsing 2D Colliders and Raycasting in Unity\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eWe use 2D colliders to detect if the bird has hit any walls and a Boolean value to determine if the bird is alive. The program casts rays in the forward, upward, and downward directions to detect if the bird has hit anything, and if it does, it checks if it is an up or down wall. This allows the program to determine if the bird has hit the top or bottom of the wall and adjust the movement accordingly.\u003c/p\u003e
\u003ch3 id=\u0022creating-the-fitness-function\u0022\u003e\u003cstrong\u003eCreating the Fitness Function\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eThe fitness function is calculated based on the distance traveled and the number of crashes. The program records the start position of the bird and updates the position and collider of the bird. If the bird hits any walls, the Boolean value is set to false, and the fitness function is adjusted accordingly. The fittest birds are then selected to reproduce and create the next generation of birds.\u003c/p\u003e
\u003ch3 id=\u0022debugging-tools-in-unity\u0022\u003e\u003cstrong\u003eDebugging Tools in Unity\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eUnity provides various debugging tools to visualize the raycasts and collisions. In this code, Unity\u0026rsquo;s debugging tools are used to visualize the raycasts and collisions. This helps in identifying any issues with the code and fixing them quickly.\u003c/p\u003e
\u003ch3 id=\u0022object-oriented-programming-in-unity\u0022\u003e\u003cstrong\u003eObject-Oriented Programming in Unity\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eThe code is written in an object-oriented style, with different classes for the bird, population, and genetic algorithm. This allows the code to be organized and maintainable, making it easier to add new features or make changes down the line.\u003c/p\u003e
\u003ch3 id=\u0022conclusion\u0022\u003e\u003cstrong\u003eConclusion\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eIn this blog, we have explored how to use genetic algorithms to train a bird to navigate through an obstacle course in Unity. We have covered the basics of genetic algorithms, how to set up an obstacle course, and how to use 2D colliders and raycasting in Unity. We have also looked at how to create a fitness function, use debugging tools, and write object-oriented code. By understanding these concepts, you will be able to create more complex games and applications using Unity and genetic algorithms.\u003c/p\u003e
`),$(".modal-title").html("Genetic Algorithms in Unity: A Flappy Bird-Inspired Game"),$(".PortfolioImage").attr("src","/images/giphy.gif"),$(".modal-container").fadeIn(),$(".modal-container").scrollTop(0)}),$(".close").click(function(){document.body.style.overflow="auto",$(".modal-container").fadeOut()}),$(".modal-container").click(function(e){e.target==this&&(document.body.style.overflow="auto",$(".modal-container").fadeOut())})})</script><script>$(document).ready(function(){$(".blog-entry[data-blog-id='12']").click(function(e){if(e.preventDefault(),document.body.style.overflow="hidden",$(".left-column").empty(),null){document.getElementById("blog-colums").className="two-columns";let e="";null.forEach(function(t){e+=`<img src="${t}" />`}),$(".left-column").html(e)}else document.getElementById("blog-colums").className="one-column";$(".blog-entry-content").html(`\u003ch3 id=\u0022description\u0022\u003e\u003cstrong\u003eDescription:\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eFor this project, I developed a Unity Pong game where a human player can play against an artificial pong paddle that is trained with an artificial neural network. The game involves bouncing a ball back and forth between two paddles, and the objective is to score points by getting the ball past the opponent\u0026rsquo;s paddle. The artificial paddle is able to learn and improve its performance over time through the use of a neural network, making it a challenging opponent for players to face.\u003c/p\u003e
\u003ch3 id=\u0022key-skills-demonstrated\u0022\u003e\u003cstrong\u003eKey Skills Demonstrated:\u003c/strong\u003e\u003c/h3\u003e
\u003cul\u003e
\u003cli\u003eGame development using Unity engine\u003c/li\u003e
\u003cli\u003eImplementation of artificial intelligence techniques, specifically neural networks\u003c/li\u003e
\u003cli\u003eObject-oriented programming principles\u003c/li\u003e
\u003cli\u003eProblem-solving and debugging skills\u003c/li\u003e
\u003c/ul\u003e
\u003ch3 id=\u0022tools-and-technologies-used\u0022\u003e\u003cstrong\u003eTools and Technologies Used:\u003c/strong\u003e\u003c/h3\u003e
\u003cul\u003e
\u003cli\u003eUnity game engine\u003c/li\u003e
\u003cli\u003eC# programming language\u003c/li\u003e
\u003cli\u003eVisual Studio code editor\u003c/li\u003e
\u003c/ul\u003e
\u003ch3 id=\u0022details\u0022\u003e\u003cstrong\u003eDetails:\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eThe game consists of three main classes: Brain, HumanPlayer, and MoveBall. The Brain class contains the neural network that controls the movement of the artificial paddle. The HumanPlayer class allows a human player to control the other paddle using keyboard input. The MoveBall class handles the movement of the ball and collision detection with the paddles and walls.\u003c/p\u003e
\u003cp\u003eThe neural network used in the game is a simple feedforward network with one hidden layer. It takes in the current position of the ball and the paddle, as well as their velocities, as input, and outputs a prediction for the vertical movement of the paddle. The weights of the neural network are updated using backpropagation and stochastic gradient descent during each training episode.\u003c/p\u003e
\u003cp\u003eDuring gameplay, the artificial paddle starts out with random weights and learns through trial and error as it plays against the human player. The performance of the paddle is evaluated based on the number of points it scores against the human player, and the weights are updated accordingly. As the paddle trains, it becomes progressively more skilled at the game, providing a challenging opponent for the human player.\u003c/p\u003e
\u003ch3 id=\u0022outcome\u0022\u003e\u003cstrong\u003eOutcome:\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eThe resulting game is a fun and engaging way for players to test their skills against an AI opponent. The use of a neural network to train the artificial paddle allows for a challenging opponent that adapts and improves over time, providing an exciting and dynamic gameplay experience. The project also demonstrates proficiency in game development and AI techniques.\u003c/p\u003e
\u003ch3 id=\u0022future-improvements\u0022\u003e\u003cstrong\u003eFuture Improvements:\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eThere are several ways that this project could be expanded and improved in the future. Some potential areas for enhancement include:\u003c/p\u003e
\u003cul\u003e
\u003cli\u003eAdding additional layers to the neural network to improve performance\u003c/li\u003e
\u003cli\u003eImplementing more advanced AI techniques, such as reinforcement learning or genetic algorithms\u003c/li\u003e
\u003cli\u003eAdding additional features to the game, such as power-ups or obstacles, to make gameplay more varied and interesting.\u003c/li\u003e
\u003c/ul\u003e
`),$(".modal-title").html("Lost in the forest in Unreal Engine"),$(".PortfolioImage").attr("src","/images/giphy.gif"),$(".modal-container").fadeIn(),$(".modal-container").scrollTop(0)}),$(".close").click(function(){document.body.style.overflow="auto",$(".modal-container").fadeOut()}),$(".modal-container").click(function(e){e.target==this&&(document.body.style.overflow="auto",$(".modal-container").fadeOut())})})</script><script>$(document).ready(function(){$(".blog-entry[data-blog-id='2']").click(function(e){if(e.preventDefault(),document.body.style.overflow="hidden",$(".left-column").empty(),null){document.getElementById("blog-colums").className="two-columns";let e="";null.forEach(function(t){e+=`<img src="${t}" />`}),$(".left-column").html(e)}else document.getElementById("blog-colums").className="one-column";$(".blog-entry-content").html(`\u003ch3 id=\u0022description\u0022\u003e\u003cstrong\u003eDescription:\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eIn this project, I created a population manager in Unity using genetic algorithms to navigate a maze. The project involved setting up a population of bots, breeding them, and evaluating their fitness in order to evolve a population that can successfully navigate a maze.\u003c/p\u003e
\u003ch3 id=\u0022key-learnings\u0022\u003e\u003cstrong\u003eKey Learnings:\u003c/strong\u003e\u003c/h3\u003e
\u003cul\u003e
\u003cli\u003eCreating a population manager in Unity using genetic algorithms\u003c/li\u003e
\u003cli\u003eImplementing fitness functions in genetic algorithms\u003c/li\u003e
\u003cli\u003eManaging data structures using lists in C#\u003c/li\u003e
\u003cli\u003eApplying good coding practices, such as commenting and using informative variable names\u003c/li\u003e
\u003cli\u003eTesting and experimenting with different parameters to fine-tune the genetic algorithm and improve the quality of the solutions it generates.\u003c/li\u003e
\u003c/ul\u003e
\u003c!-- raw HTML omitted --\u003e
\u003c!-- raw HTML omitted --\u003e
\u003ch3 id=\u0022tools-and-technologies-used\u0022\u003e\u003cstrong\u003eTools and Technologies Used:\u003c/strong\u003e\u003c/h3\u003e
\u003cul\u003e
\u003cli\u003eUnity game engine\u003c/li\u003e
\u003cli\u003eC# programming language\u003c/li\u003e
\u003c/ul\u003e
\u003ch3 id=\u0022outcome\u0022\u003e\u003cstrong\u003eOutcome:\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eThe project resulted in a working genetic algorithm that successfully navigated through a maze. It demonstrated my ability to apply genetic algorithms in game development, and my proficiency in using Unity and C# to implement complex solutions.\u003c/p\u003e
\u003ch3 id=\u0022future-improvements\u0022\u003e\u003cstrong\u003eFuture Improvements:\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eOne potential area for future improvement would be to explore different selection and mutation strategies to improve the performance of the genetic algorithm. Additionally, the project could be expanded to include more complex mazes or other challenges that require navigation and decision-making.\u003c/p\u003e
`),$(".modal-title").html("Maze Walking with Genetic Algorithms in Unity"),$(".PortfolioImage").attr("src","/images/giphy.gif"),$(".modal-container").fadeIn(),$(".modal-container").scrollTop(0)}),$(".close").click(function(){document.body.style.overflow="auto",$(".modal-container").fadeOut()}),$(".modal-container").click(function(e){e.target==this&&(document.body.style.overflow="auto",$(".modal-container").fadeOut())})})</script><script>$(document).ready(function(){$(".blog-entry[data-blog-id='4']").click(function(e){if(e.preventDefault(),document.body.style.overflow="hidden",$(".left-column").empty(),null){document.getElementById("blog-colums").className="two-columns";let e="";null.forEach(function(t){e+=`<img src="${t}" />`}),$(".left-column").html(e)}else document.getElementById("blog-colums").className="one-column";$(".blog-entry-content").html(`\u003ch3 id=\u0022description\u0022\u003e\u003cstrong\u003eDescription:\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eIn this project, I created a genetic algorithm to train bots to survive on a long, narrow beam in a Unity game environment. The algorithm used a fitness function based on the distance traveled by each bot to encourage them to move along the platform rather than just jumping up and down or standing still. The project also included the creation of a population manager to handle the selection and breeding of new solutions.\u003c/p\u003e
\u003ch3 id=\u0022key-skills-demonstrated\u0022\u003e\u003cstrong\u003eKey Skills Demonstrated:\u003c/strong\u003e\u003c/h3\u003e
\u003cul\u003e
\u003cli\u003eGenetic algorithms\u003c/li\u003e
\u003cli\u003eUnity game development\u003c/li\u003e
\u003cli\u003eFitness function design\u003c/li\u003e
\u003cli\u003ePopulation management\u003c/li\u003e
\u003cli\u003eObject-oriented programming\u003c/li\u003e
\u003c/ul\u003e
\u003ch3 id=\u0022tools-and-technologies-used\u0022\u003e\u003cstrong\u003eTools and Technologies Used:\u003c/strong\u003e\u003c/h3\u003e
\u003cul\u003e
\u003cli\u003eUnity game engine\u003c/li\u003e
\u003cli\u003eC# programming language\u003c/li\u003e
\u003c/ul\u003e
\u003ch3 id=\u0022details\u0022\u003e\u003cstrong\u003eDetails:\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eThe project began with the creation of a DNA code to represent the genes of each bot. The code was initialized with random values within a specific range and then used to control the behavior of the bot. The population manager was then created to manage the population of bots and handle the selection and breeding of new solutions. The fitness function was based on the distance traveled by each bot, encouraging them to move along the platform rather than just jumping up and down or standing still.\u003c/p\u003e
\u003ch3 id=\u0022outcome\u0022\u003e\u003cstrong\u003eOutcome:\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eThe genetic algorithm was successful in training the bots to stay alive on the platform and move along it. The project demonstrated the effectiveness of genetic algorithms in training agents to perform specific tasks in a game environment. The skills demonstrated in the project can be applied to a wide range of applications in machine learning, optimization, and robotics.\u003c/p\u003e
\u003ch3 id=\u0022future-improvements\u0022\u003e\u003cstrong\u003eFuture Improvements:\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eOne potential improvement for the project would be to incorporate additional variables into the fitness function to make it more robust. Additionally, implementing a more sophisticated selection process could further improve the algorithm\u0026rsquo;s performance.\u003c/p\u003e
`),$(".modal-title").html("Movement with Genetic algorithms in unity"),$(".PortfolioImage").attr("src","/images/giphy.gif"),$(".modal-container").fadeIn(),$(".modal-container").scrollTop(0)}),$(".close").click(function(){document.body.style.overflow="auto",$(".modal-container").fadeOut()}),$(".modal-container").click(function(e){e.target==this&&(document.body.style.overflow="auto",$(".modal-container").fadeOut())})})</script><script>$(document).ready(function(){$(".blog-entry[data-blog-id='5']").click(function(e){if(e.preventDefault(),document.body.style.overflow="hidden",$(".left-column").empty(),null){document.getElementById("blog-colums").className="two-columns";let e="";null.forEach(function(t){e+=`<img src="${t}" />`}),$(".left-column").html(e)}else document.getElementById("blog-colums").className="one-column";$(".blog-entry-content").html(`\u003ch3 id=\u0022description\u0022\u003e\u003cstrong\u003eDescription:\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eFor this project, I developed a Unity Pong game where a human player can play against an artificial pong paddle that is trained with an artificial neural network. The game involves bouncing a ball back and forth between two paddles, and the objective is to score points by getting the ball past the opponent\u0026rsquo;s paddle. The artificial paddle is able to learn and improve its performance over time through the use of a neural network, making it a challenging opponent for players to face.\u003c/p\u003e
\u003ch3 id=\u0022key-skills-demonstrated\u0022\u003e\u003cstrong\u003eKey Skills Demonstrated:\u003c/strong\u003e\u003c/h3\u003e
\u003cul\u003e
\u003cli\u003eGame development using Unity engine\u003c/li\u003e
\u003cli\u003eImplementation of artificial intelligence techniques, specifically neural networks\u003c/li\u003e
\u003cli\u003eObject-oriented programming principles\u003c/li\u003e
\u003cli\u003eProblem-solving and debugging skills\u003c/li\u003e
\u003c/ul\u003e
\u003ch3 id=\u0022tools-and-technologies-used\u0022\u003e\u003cstrong\u003eTools and Technologies Used:\u003c/strong\u003e\u003c/h3\u003e
\u003cul\u003e
\u003cli\u003eUnity game engine\u003c/li\u003e
\u003cli\u003eC# programming language\u003c/li\u003e
\u003cli\u003eVisual Studio code editor\u003c/li\u003e
\u003c/ul\u003e
\u003ch3 id=\u0022details\u0022\u003e\u003cstrong\u003eDetails:\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eThe game consists of three main classes: Brain, HumanPlayer, and MoveBall. The Brain class contains the neural network that controls the movement of the artificial paddle. The HumanPlayer class allows a human player to control the other paddle using keyboard input. The MoveBall class handles the movement of the ball and collision detection with the paddles and walls.\u003c/p\u003e
\u003cp\u003eThe neural network used in the game is a simple feedforward network with one hidden layer. It takes in the current position of the ball and the paddle, as well as their velocities, as input, and outputs a prediction for the vertical movement of the paddle. The weights of the neural network are updated using backpropagation and stochastic gradient descent during each training episode.\u003c/p\u003e
\u003cp\u003eDuring gameplay, the artificial paddle starts out with random weights and learns through trial and error as it plays against the human player. The performance of the paddle is evaluated based on the number of points it scores against the human player, and the weights are updated accordingly. As the paddle trains, it becomes progressively more skilled at the game, providing a challenging opponent for the human player.\u003c/p\u003e
\u003ch3 id=\u0022outcome\u0022\u003e\u003cstrong\u003eOutcome:\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eThe resulting game is a fun and engaging way for players to test their skills against an AI opponent. The use of a neural network to train the artificial paddle allows for a challenging opponent that adapts and improves over time, providing an exciting and dynamic gameplay experience. The project also demonstrates proficiency in game development and AI techniques.\u003c/p\u003e
\u003ch3 id=\u0022future-improvements\u0022\u003e\u003cstrong\u003eFuture Improvements:\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eThere are several ways that this project could be expanded and improved in the future. Some potential areas for enhancement include:\u003c/p\u003e
\u003cul\u003e
\u003cli\u003eAdding additional layers to the neural network to improve performance\u003c/li\u003e
\u003cli\u003eImplementing more advanced AI techniques, such as reinforcement learning or genetic algorithms\u003c/li\u003e
\u003cli\u003eAdding additional features to the game, such as power-ups or obstacles, to make gameplay more varied and interesting.\u003c/li\u003e
\u003c/ul\u003e
`),$(".modal-title").html("Pong ANN in Unity"),$(".PortfolioImage").attr("src","/images/giphy.gif"),$(".modal-container").fadeIn(),$(".modal-container").scrollTop(0)}),$(".close").click(function(){document.body.style.overflow="auto",$(".modal-container").fadeOut()}),$(".modal-container").click(function(e){e.target==this&&(document.body.style.overflow="auto",$(".modal-container").fadeOut())})})</script><script>$(document).ready(function(){$(".blog-entry[data-blog-id='7']").click(function(e){if(e.preventDefault(),document.body.style.overflow="hidden",$(".left-column").empty(),null){document.getElementById("blog-colums").className="two-columns";let e="";null.forEach(function(t){e+=`<img src="${t}" />`}),$(".left-column").html(e)}else document.getElementById("blog-colums").className="one-column";$(".blog-entry-content").html(`\u003ch3 id=\u0022project-overview\u0022\u003e\u003cstrong\u003eProject Overview\u003c/strong\u003e\u003c/h3\u003e
\u003cul\u003e
\u003cli\u003e
\u003cp\u003eName: Sea Monsters Assault\u003c/p\u003e
\u003c/li\u003e
\u003cli\u003e
\u003cp\u003eType: 2D game\u003c/p\u003e
\u003c/li\u003e
\u003cli\u003e
\u003cp\u003ePlatform: PC\u003c/p\u003e
\u003c/li\u003e
\u003cli\u003e
\u003cp\u003eTools: Python, Pygame, DallE\u003c/p\u003e
\u003c/li\u003e
\u003c/ul\u003e
\u003ch3 id=\u0022description\u0022\u003e\u003cstrong\u003eDescription\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eSea Monsters Assault is a 2D game where the player defends their beach from waves of sea monsters. The player must shoot down the monsters before they reach the shore, while avoiding their attacks. The game features multiple rounds of increasing difficulty, with new types of monsters and power-ups to unlock. The game\u0026rsquo;s graphics are generated using DallE, an AI-powered image generation tool.\u003c/p\u003e
\u003ch3 id=\u0022goals-and-objectives\u0022\u003e\u003cstrong\u003eGoals and Objectives\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eThe main goal of the project was to create a fun and challenging game using Python and Pygame, while showcasing the potential of AI-generated graphics. The objectives were to implement the game mechanics, design and generate the game\u0026rsquo;s graphics using DallE, and add sound and music effects to enhance the gameplay experience.\u003c/p\u003e
\u003ch3 id=\u0022tools-and-technologies-used\u0022\u003e\u003cstrong\u003eTools and Technologies Used:\u003c/strong\u003e\u003c/h3\u003e
\u003cul\u003e
\u003cli\u003ePython\u003c/li\u003e
\u003cli\u003eVisual studio code\u003c/li\u003e
\u003cli\u003eStable diffusion\u003c/li\u003e
\u003c/ul\u003e
\u003ch3 id=\u0022development-process\u0022\u003e\u003cstrong\u003eDevelopment Process\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eThe development process involved several stages, starting with the initial concept and design, followed by the implementation of the game mechanics and logic, the integration of DallE-generated graphics, and the addition of sound and music effects. The code was tested and debugged extensively, with frequent iterations to improve the gameplay and user experience.\u003c/p\u003e
\u003ch3 id=\u0022design-and-art\u0022\u003e\u003cstrong\u003eDesign and Art\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eThe game\u0026rsquo;s design and art were created using DallE, an AI-powered image generation tool that uses machine learning to generate images from textual descriptions. The tool allowed us to create a wide variety of sea monsters and beach scenery, with different colors, shapes, and sizes, while minimizing the need for manual pixel art or illustration. This approach saved time and resources while achieving a unique and visually appealing style for the game.\u003c/p\u003e
\u003ch3 id=\u0022programming\u0022\u003e\u003cstrong\u003eProgramming\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eThe game was programmed using Python and Pygame, a popular game development library for Python. The code includes various functions, classes, and objects to handle the game mechanics and logic, such as the GameManager class, the update() and draw() functions, the shift_monsters(), check_round_completion(), check_collisions(), start_new_round(), and check_game_status() functions. The code also uses the Pygame mixer library to load and play sound effects during the gameplay.\u003c/p\u003e
\u003ch3 id=\u0022sound-and-music\u0022\u003e\u003cstrong\u003eSound and Music\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eThe game features sound and music effects that enhance the gameplay experience and create a more immersive environment. The sound effects include monster roars, bullet shots, and explosions, while the music sets the mood and pace of the game. The audio files were sourced from royalty-free libraries and edited to fit the game\u0026rsquo;s theme and tone.\u003c/p\u003e
\u003ch3 id=\u0022future-plans\u0022\u003e\u003cstrong\u003eFuture Plans\u003c/strong\u003e\u003c/h3\u003e
\u003cp\u003eThe game can be further developed and expanded with additional features and content, such as new types of monsters, power-ups, and challenges. The game\u0026rsquo;s AI-generated graphics can also be improved and diversified by training the DallE model with more data and refining the textual descriptions. The game can also be ported to other platforms, such as mobile devices or consoles, to reach a wider audience.\u003c/p\u003e
`),$(".modal-title").html("Sea monsters assault 2D game"),$(".PortfolioImage").attr("src","/images/giphy.gif"),$(".modal-container").fadeIn(),$(".modal-container").scrollTop(0)}),$(".close").click(function(){document.body.style.overflow="auto",$(".modal-container").fadeOut()}),$(".modal-container").click(function(e){e.target==this&&(document.body.style.overflow="auto",$(".modal-container").fadeOut())})})</script><div class=modal-container><div class=modal id=blog-modal><span class=close>&#215;</span><section><article class=modal-article><header class=modal-header><h2 class=modal-title></h2><p class=date>February 24, 2023</p></header><div style=text-align:center><img class=PortfolioImage style=width:40%></div><div id=blog-colums class=two-columns><div class=left-column></div><div class=right-column><div class=blog-entry-content style=font-size:80%></div></div></div></article></section></div></div></body></html>